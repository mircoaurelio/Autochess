<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Mobile Chess Pieces — Drag & Drop</title>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.min.js"></script>
    <style>
      :root {
        color-scheme: light dark;
      }
      html, body {
        height: 100%;
      }
      body {
        margin: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: radial-gradient(1000px 600px at 50% 0%, rgba(0,0,0,0.06), transparent 60%),
                    linear-gradient(180deg, rgba(0,0,0,0.03), transparent 200px);
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, DejaVu Sans, Arial, Helvetica, sans-serif;
      }
      .container {
        width: min(920px, 96vw);
        height: min(620px, 92vh);
        display: grid;
        grid-template-rows: auto 1fr;
        gap: 10px;
      }
      header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 6px 4px;
        color: #444;
      }
      header h1 {
        font-size: 16px;
        margin: 0;
        font-weight: 600;
        letter-spacing: 0.2px;
      }
      header .hint {
        font-size: 12px;
        opacity: 0.8;
      }
      #canvas-wrapper {
        position: relative;
        border-radius: 10px;
        overflow: hidden;
        box-shadow: 0 8px 30px rgba(0,0,0,0.08), 0 2px 10px rgba(0,0,0,0.06);
        background: #f6f7f9;
      }
      /* Prevent scroll/jank during touch-drag over the canvas */
      #canvas-wrapper, #canvas-wrapper canvas { touch-action: none; }
      canvas { display: block; }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>Chess Piece Placement — 3×2 Grid</h1>
        <div class="hint">Drag from palette or select then tap a cell</div>
      </header>
      <div id="canvas-wrapper"></div>
    </div>

    <script>
      // --- Layout (responsive) --------------------------------------------
      const GRID_COLS = 3;
      const GRID_ROWS = 2;
      // Dynamic layout values computed in computeLayout()
      let CELL_SIZE = 120; // grid cell size in px
      let GRID_GAP = 6;

      // Canvas sizing
      let CANVAS_PADDING = 24; // internal padding around content
      let RIGHT_PANEL_WIDTH = 280; // palette + UI
      let BOTTOM_BAR_HEIGHT = 0; // reserved if needed later

      // Derived canvas size
      let GRID_WIDTH = GRID_COLS * CELL_SIZE + (GRID_COLS - 1) * GRID_GAP;
      let GRID_HEIGHT = GRID_ROWS * CELL_SIZE + (GRID_ROWS - 1) * GRID_GAP;
      let CANVAS_WIDTH = CANVAS_PADDING * 2 + GRID_WIDTH + RIGHT_PANEL_WIDTH;
      let CANVAS_HEIGHT = Math.max(
        CANVAS_PADDING * 2 + GRID_HEIGHT,
        CANVAS_PADDING * 2 + 360
      ) + BOTTOM_BAR_HEIGHT;

      // Grid origin (top-left)
      let GRID_ORIGIN_X = CANVAS_PADDING;
      let GRID_ORIGIN_Y = CANVAS_PADDING;

      // Right panel origin
      let PANEL_X = GRID_ORIGIN_X + GRID_WIDTH + 24;
      let PANEL_Y = CANVAS_PADDING;

      // Palette layout
      let PALETTE_CELL = 64;
      let PALETTE_GAP = 12;

      // Unicode chess piece characters
      const PIECES = ["king", "queen", "rook", "bishop", "knight", "pawn"];
      const UNICODE = {
        white: {
          king: "\u2654",
          queen: "\u2655",
          rook: "\u2656",
          bishop: "\u2657",
          knight: "\u2658",
          pawn: "\u2659",
        },
        black: {
          king: "\u265A",
          queen: "\u265B",
          rook: "\u265C",
          bishop: "\u265D",
          knight: "\u265E",
          pawn: "\u265F",
        },
      };

      // Pre-rendered piece images for crisp rendering on canvas
      /** @type {{white: Record<string, p5.Image>, black: Record<string, p5.Image>}} */
      const pieceImages = { white: {}, black: {} };

      // Grid state: array of { type, color } or null
      /** @type {(null | {type: string, color: 'white'|'black'})[][]} */
      let grid = [];

      // Selected color and piece (for tap-to-place)
      /** @type {'white'|'black'} */
      let selectedColor = 'white';
      /** @type {null | {type: string, color: 'white'|'black'}} */
      let selectedPiece = null;

      // Drag state
      /** @type {null | {piece: {type: string, color: 'white'|'black'}, from: 'palette'|'grid', originCell?: {c:number,r:number}}} */
      let dragging = null;

      // Hover state
      let hoverCell = null; // {c, r} or null

      // Trash area & Clear button rects computed on the fly to be robust
      function trashRect() {
        return { x: PANEL_X, y: PANEL_Y + 260, w: RIGHT_PANEL_WIDTH - 36, h: 56 };
      }
      function clearRect() {
        const t = trashRect();
        return { x: PANEL_X, y: t.y + t.h + 14, w: RIGHT_PANEL_WIDTH - 36, h: 44 };
      }

      // Utility: point in rect
      function inRect(x, y, rect) {
        return x >= rect.x && x <= rect.x + rect.w && y >= rect.y && y <= rect.y + rect.h;
      }

      // Get grid cell at a position
      function cellAt(x, y) {
        const localX = x - GRID_ORIGIN_X;
        const localY = y - GRID_ORIGIN_Y;
        if (localX < 0 || localY < 0) return null;
        // account for gaps
        for (let r = 0; r < GRID_ROWS; r++) {
          for (let c = 0; c < GRID_COLS; c++) {
            const cx = c * (CELL_SIZE + GRID_GAP);
            const cy = r * (CELL_SIZE + GRID_GAP);
            const rect = { x: cx, y: cy, w: CELL_SIZE, h: CELL_SIZE };
            if (
              localX >= rect.x && localX <= rect.x + rect.w &&
              localY >= rect.y && localY <= rect.y + rect.h
            ) {
              return { c, r };
            }
          }
        }
        return null;
      }

      // Get palette cell rect for a given piece index
      function paletteRect(i) {
        const cols = 2; // layout 2 columns x 3 rows
        const row = Math.floor(i / cols);
        const col = i % cols;
        const x = PANEL_X + 6 + col * (PALETTE_CELL + PALETTE_GAP);
        const y = PANEL_Y + 56 + row * (PALETTE_CELL + PALETTE_GAP);
        return { x, y, w: PALETTE_CELL, h: PALETTE_CELL };
      }

      // Responsive layout computation
      function computeLayout() {
        const containerEl = document.querySelector('.container');
        const containerW = containerEl ? containerEl.clientWidth : window.innerWidth;
        const isNarrow = containerW < 640;

        // Base paddings
        CANVAS_PADDING = isNarrow ? 16 : 24;
        GRID_GAP = 6;

        if (!isNarrow) {
          RIGHT_PANEL_WIDTH = Math.max(220, Math.min(320, Math.floor(containerW * 0.34)));
          const gridAreaW = containerW - RIGHT_PANEL_WIDTH - CANVAS_PADDING * 2 - 24;
          CELL_SIZE = Math.floor(Math.max(84, Math.min(120, (gridAreaW - (GRID_COLS - 1) * GRID_GAP) / GRID_COLS)));
          PALETTE_CELL = Math.floor(Math.max(56, Math.min(76, CELL_SIZE * 0.62)));

          GRID_WIDTH = GRID_COLS * CELL_SIZE + (GRID_COLS - 1) * GRID_GAP;
          GRID_HEIGHT = GRID_ROWS * CELL_SIZE + (GRID_ROWS - 1) * GRID_GAP;
          GRID_ORIGIN_X = CANVAS_PADDING;
          GRID_ORIGIN_Y = CANVAS_PADDING + 22;
          PANEL_X = GRID_ORIGIN_X + GRID_WIDTH + 24;
          PANEL_Y = CANVAS_PADDING + 22;
          CANVAS_WIDTH = CANVAS_PADDING * 2 + GRID_WIDTH + RIGHT_PANEL_WIDTH + 24;
          CANVAS_HEIGHT = Math.max(
            CANVAS_PADDING * 2 + GRID_HEIGHT + 22,
            CANVAS_PADDING * 2 + 380
          );
        } else {
          RIGHT_PANEL_WIDTH = containerW - CANVAS_PADDING * 2;
          const gridAreaW = containerW - CANVAS_PADDING * 2;
          CELL_SIZE = Math.floor(Math.max(76, Math.min(110, (gridAreaW - (GRID_COLS - 1) * GRID_GAP) / GRID_COLS)));
          PALETTE_CELL = Math.floor(Math.max(52, Math.min(68, CELL_SIZE * 0.6)));

          GRID_WIDTH = GRID_COLS * CELL_SIZE + (GRID_COLS - 1) * GRID_GAP;
          GRID_HEIGHT = GRID_ROWS * CELL_SIZE + (GRID_ROWS - 1) * GRID_GAP;
          GRID_ORIGIN_X = Math.floor((containerW - GRID_WIDTH) / 2);
          GRID_ORIGIN_Y = CANVAS_PADDING + 22;
          PANEL_X = CANVAS_PADDING;
          PANEL_Y = GRID_ORIGIN_Y + GRID_HEIGHT + 24;
          const panelBlockH = 56 + (PALETTE_CELL * 3 + PALETTE_GAP * 2) + 160;
          CANVAS_WIDTH = containerW;
          CANVAS_HEIGHT = PANEL_Y + panelBlockH + CANVAS_PADDING;
        }
      }

      function setup() {
        // Compute initial responsive layout
        computeLayout();
        const cnv = createCanvas(CANVAS_WIDTH, CANVAS_HEIGHT);
        cnv.parent('canvas-wrapper');
        // Avoid page scrolling during drag on mobile
        cnv.elt.style.touchAction = 'none';
        textAlign(CENTER, CENTER);
        textSize(48);

        // init grid
        grid = Array.from({ length: GRID_ROWS }, () => Array(GRID_COLS).fill(null));

        // Generate piece images once
        generatePieceImages();
      }

      function draw() {
        clear();
        background(245);

        // Slight vignette
        noStroke();
        for (let i = 0; i < 3; i++) {
          fill(0, 0, 0, 12 - i * 4);
          rect(8 + i, 8 + i, width - 16 - 2 * i, height - 16 - 2 * i, 14);
        }

        // Main card background
        fill(252);
        rect(10, 10, width - 20, height - 20, 12);

        drawGrid();
        drawRightPanel();
        drawDraggingPreview();

        // Hover cell highlight (if not dragging or even while dragging)
        const over = cellAt(mouseX, mouseY);
        hoverCell = over;
        if (over) {
          const { x, y, w, h } = cellRect(over.c, over.r);
          noFill();
          stroke(60, 120, 255);
          strokeWeight(2);
          rect(x - 1, y - 1, w + 2, h + 2, 8);
        }
      }

      // Recompute layout on resize
      function windowResized() {
        computeLayout();
        resizeCanvas(CANVAS_WIDTH, CANVAS_HEIGHT);
      }

      function drawGrid() {
        // Title
        noStroke();
        fill(20);
        textSize(16);
        textStyle(BOLD);
        text('Grid (3 × 2)', GRID_ORIGIN_X + GRID_WIDTH / 2, GRID_ORIGIN_Y - 16);
        textStyle(NORMAL);

        // Board squares
        for (let r = 0; r < GRID_ROWS; r++) {
          for (let c = 0; c < GRID_COLS; c++) {
            const { x, y, w, h } = cellRect(c, r);
            const isDark = (r + c) % 2 === 1;
            noStroke();
            fill(isDark ? 210 : 232);
            rect(x, y, w, h, 10);

            // piece
            const piece = grid[r][c];
            if (piece) {
              drawPieceAt(piece, x + w / 2, y + h / 2, Math.floor(CELL_SIZE * 0.5));
            }
          }
        }
      }

      function drawRightPanel() {
        // Panel card
        noStroke();
        fill(248);
        rect(PANEL_X - 12, PANEL_Y - 12, RIGHT_PANEL_WIDTH, CANVAS_HEIGHT - PANEL_Y*2 + 24, 12);

        // Palette title
        fill(20);
        textSize(16);
        textStyle(BOLD);
        text('Palette', PANEL_X + (RIGHT_PANEL_WIDTH - 24)/2, PANEL_Y);
        textStyle(NORMAL);

        // Color toggle
        drawColorToggle();

        // Palette grid
        for (let i = 0; i < PIECES.length; i++) {
          const rectP = paletteRect(i);
          // tile
          noStroke();
          fill(240);
          rect(rectP.x, rectP.y, rectP.w, rectP.h, 10);

          // outline and hover
          const isOver = inRect(mouseX, mouseY, rectP);
          noFill();
          stroke(isOver ? color(60, 120, 255) : color(190));
          strokeWeight(isOver ? 2 : 1);
          rect(rectP.x, rectP.y, rectP.w, rectP.h, 10);

          const type = PIECES[i];
          const isSelected = selectedPiece && selectedPiece.type === type && selectedPiece.color === selectedColor;
          if (isSelected) {
            noFill();
            stroke(60, 120, 255);
            strokeWeight(3);
            rect(rectP.x - 3, rectP.y - 3, rectP.w + 6, rectP.h + 6, 12);
          }

          drawPieceAt({ type, color: selectedColor }, rectP.x + rectP.w / 2, rectP.y + rectP.h / 2, Math.floor(PALETTE_CELL * 0.7));
        }

        // Trash area
        drawTrash();

        // Clear button
        drawClearButton();

        // Help text
        fill(40);
        textSize(12);
        textAlign(LEFT, CENTER);
        const cR = clearRect();
        text('\u2022 Drag from palette onto grid\n\u2022 Or tap-select piece then tap a cell\n\u2022 Drag existing pieces to move or drop in Trash', PANEL_X - 4, cR.y + cR.h + 26);
        textAlign(CENTER, CENTER);
      }

      function drawPieceAt(piece, cx, cy, sizePx) {
        const img = pieceImages[piece.color][piece.type];
        if (!img) return;
        imageMode(CENTER);
        image(img, cx, cy, sizePx, sizePx);
        imageMode(CORNER);
      }

      function drawTrash() {
        const r = trashRect();
        // background
        noStroke();
        fill(255, 230, 230);
        rect(r.x, r.y, r.w, r.h, 10);
        // border
        const over = inRect(mouseX, mouseY, r);
        noFill();
        stroke(over ? color(220, 80, 80) : color(200, 120, 120));
        strokeWeight(over ? 2 : 1.2);
        rect(r.x, r.y, r.w, r.h, 10);
        // label
        fill(150, 40, 40);
        textSize(14);
        text('\ud83d\uddd1\ufe0f  Drop here to delete', r.x + r.w / 2, r.y + r.h / 2);
      }

      function drawClearButton() {
        const r = clearRect();
        const over = inRect(mouseX, mouseY, r);
        // background
        noStroke();
        fill(over ? 235 : 242);
        rect(r.x, r.y, r.w, r.h, 10);
        // border
        noFill();
        stroke(over ? color(60, 120, 255) : color(190));
        strokeWeight(over ? 2 : 1);
        rect(r.x, r.y, r.w, r.h, 10);
        // label
        fill(30);
        textSize(14);
        text('Clear Grid', r.x + r.w / 2, r.y + r.h / 2);
      }

      function drawColorToggle() {
        const toggleRect = { x: PANEL_X + 6, y: PANEL_Y + 16, w: RIGHT_PANEL_WIDTH - 36, h: 28 };
        const half = toggleRect.w / 2;
        // background
        noStroke();
        fill(238);
        rect(toggleRect.x, toggleRect.y, toggleRect.w, toggleRect.h, 14);

        // knobs
        const leftRect = { x: toggleRect.x + 2, y: toggleRect.y + 2, w: half - 4, h: toggleRect.h - 4 };
        const rightRect = { x: toggleRect.x + 2 + half, y: toggleRect.y + 2, w: half - 4, h: toggleRect.h - 4 };

        // selected background
        noStroke();
        if (selectedColor === 'white') {
          fill(255);
          rect(leftRect.x, leftRect.y, leftRect.w, leftRect.h, 12);
        } else {
          fill(230);
          rect(rightRect.x, rightRect.y, rightRect.w, rightRect.h, 12);
        }

        // outlines
        noFill();
        stroke(180);
        rect(leftRect.x, leftRect.y, leftRect.w, leftRect.h, 12);
        rect(rightRect.x, rightRect.y, rightRect.w, rightRect.h, 12);

        // labels
        noStroke();
        fill(30);
        textSize(13);
        text('White', leftRect.x + leftRect.w / 2, leftRect.y + leftRect.h / 2);
        text('Black', rightRect.x + rightRect.w / 2, rightRect.y + rightRect.h / 2);

        // store hit regions for click handling
        drawColorToggle.leftRect = leftRect;
        drawColorToggle.rightRect = rightRect;
      }

      function cellRect(c, r) {
        const x = GRID_ORIGIN_X + c * (CELL_SIZE + GRID_GAP);
        const y = GRID_ORIGIN_Y + r * (CELL_SIZE + GRID_GAP);
        return { x, y, w: CELL_SIZE, h: CELL_SIZE };
      }

      function drawDraggingPreview() {
        if (!dragging) return;
        const piece = dragging.piece;
        // highlight drop cell
        const target = cellAt(mouseX, mouseY);
        if (target) {
          const { x, y, w, h } = cellRect(target.c, target.r);
          noFill();
          stroke(60, 120, 255);
          strokeWeight(3);
          rect(x - 2, y - 2, w + 4, h + 4, 12);
        }
        drawPieceAt(piece, mouseX, mouseY, Math.floor(CELL_SIZE * 0.5));
      }

      function mousePressed() {
        // If clicking on a grid piece, start dragging it
        const cell = cellAt(mouseX, mouseY);
        if (cell) {
          const piece = grid[cell.r][cell.c];
          if (piece) {
            dragging = { piece: { ...piece }, from: 'grid', originCell: { ...cell } };
            // Temporarily remove it from the grid for visual correctness while dragging
            grid[cell.r][cell.c] = null;
            return;
          }
        }

        // If clicking on a palette piece, start dragging that piece
        for (let i = 0; i < PIECES.length; i++) {
          const rectP = paletteRect(i);
          if (inRect(mouseX, mouseY, rectP)) {
            const type = PIECES[i];
            dragging = { piece: { type, color: selectedColor }, from: 'palette' };
            return;
          }
        }
      }

      function mouseReleased() {
        if (!dragging) return;
        const dropping = dragging;
        dragging = null;

        // If dropped over grid, place piece
        const cell = cellAt(mouseX, mouseY);
        if (cell) {
          grid[cell.r][cell.c] = { ...dropping.piece };
          return;
        }

        // If dropped over trash and started from grid -> delete
        if (inRect(mouseX, mouseY, trashRect()) && dropping.from === 'grid') {
          // do nothing (piece removed)
          return;
        }

        // Otherwise, if it originated from grid, restore to origin
        if (dropping.from === 'grid' && dropping.originCell) {
          const { r, c } = dropping.originCell;
          if (!grid[r][c]) {
            grid[r][c] = { ...dropping.piece };
          } else {
            // If somehow occupied, find first empty cell to restore
            outer: for (let rr = 0; rr < GRID_ROWS; rr++) {
              for (let cc = 0; cc < GRID_COLS; cc++) {
                if (!grid[rr][cc]) { grid[rr][cc] = { ...dropping.piece }; break outer; }
              }
            }
          }
        }
      }

      function mouseClicked() {
        // Color toggle clicks
        if (drawColorToggle.leftRect && inRect(mouseX, mouseY, drawColorToggle.leftRect)) {
          selectedColor = 'white';
          return;
        }
        if (drawColorToggle.rightRect && inRect(mouseX, mouseY, drawColorToggle.rightRect)) {
          selectedColor = 'black';
          return;
        }

        // Clear button
        if (inRect(mouseX, mouseY, clearRect())) {
          for (let r = 0; r < GRID_ROWS; r++) {
            for (let c = 0; c < GRID_COLS; c++) grid[r][c] = null;
          }
          return;
        }

        // Palette select (for tap-to-place)
        for (let i = 0; i < PIECES.length; i++) {
          const rectP = paletteRect(i);
          if (inRect(mouseX, mouseY, rectP)) {
            const type = PIECES[i];
            if (selectedPiece && selectedPiece.type === type && selectedPiece.color === selectedColor) {
              selectedPiece = null; // toggle off
            } else {
              selectedPiece = { type, color: selectedColor };
            }
            return;
          }
        }

        // Tap-to-place onto grid
        const cell = cellAt(mouseX, mouseY);
        if (cell && selectedPiece) {
          grid[cell.r][cell.c] = { ...selectedPiece };
          return;
        }
      }

      // Optional: support touch as well (mobile)
      function touchStarted() {
        // mirror mousePressed behavior for single touch
        if (touches.length > 1) return; // ignore multi-touch
        mousePressed();
        return false;
      }
      function touchEnded() {
        if (touches.length > 0) return; // still touching
        mouseReleased();
        return false;
      }

      function touchMoved() {
        // Prevent page scroll during dragging
        return false;
      }

      // Render unicode glyphs into images to use as sprites
      function generatePieceImages() {
        const base = 256; // high resolution for crisp scaling
        for (const color of ['white', 'black']) {
          for (const type of PIECES) {
            const g = createGraphics(base, base);
            g.pixelDensity(1);
            g.clear();
            g.textAlign(CENTER, CENTER);
            g.textSize(Math.floor(base * 0.78));
            // Shadow
            g.fill(0, 0, 0, 60);
            g.text(UNICODE[color][type], base / 2 + base * 0.015, base / 2 + base * 0.02);
            // Foreground
            g.fill(color === 'white' ? 255 : 24);
            g.text(UNICODE[color][type], base / 2, base / 2);
            pieceImages[color][type] = g.get();
          }
        }
      }
    </script>
  </body>
</html>
